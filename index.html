<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ornithological Blogpoem</title>
</head>
<body>

<div id="buttons" align="center">

<button id="listen" class="off">Listen</button>
<button id="nudge" class="off">Nudge</button>

</div>

<p>
"Ornithological Blogpoem" by
<a href="https://twitter.com/egabbert">Elisa Gabbert</a>.

</p>

<script src="scripts/BufferLoader.js"></script>

<script type="text/javascript">

// initializing our cues2Play variable
var cues2Play = { cue0: "off", cue1 : "off", cue2 : "off", pitch : 1. };

// getting references to our buttons from the parent object
var listenButton = document.getElementById("listen");
// nudgeButton doesn't work yet
var nudgeButton = document.getElementById("nudge");

// setting up what functions get called when the buttons are clicked
// for now, nudgeButton just plays a sound as a test.
listenButton.onclick = listenButtonClicked;
nudgeButton.onclick = nudgeButtonClicked;

// setting up our audio context and creating our master gain
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioCtx = new AudioContext();

var gainNode = audioCtx.createGain();
gainNode.connect(audioCtx.destination);
gainNode.gain.value = 1.0;

var soundNode;

var fileList = ['birds01.wav', 'birds02.wav', 'birds03.wav'];
      
var audioBuffers = [];

function getRandomFileNames(fileList, desiredFileNumber) {
	var randomFiles = [];
	if (fileList.length >= desiredFileNumber) {
		var currentFile;
		while (randomFiles.length < desiredFileNumber) {
			var newFileIndex = Math.floor(Math.random() * fileList.length);
			newFile = fileList[newFileIndex];
			if (randomFiles.indexOf(newFile) < 0) {
				randomFiles.push(newFile);
			}
		}
	} else {
		randomFiles = fileList;
	}
	return randomFiles;
}

var randomFiles = getRandomFileNames(fileList, 3);
//alert(randomFiles);

bufferLoader = new BufferLoader(audioCtx, 
		'sounds/uncompressed/',
		randomFiles, 
		 finishedLoading);
bufferLoader.load();

function finishedLoading(bufferList) {
	for (var i = 0; i < bufferList.length; ++i) {
		audioBuffers[i] = bufferList[i];
	}
	buffersAreLoaded = true;
	//alert(audioBuffers);
}

// See the comments in the PlayFile3 demo to review what's going on each of these steps
// And for some other options of what you can do when playing back a sound
function button0Clicked() {
	playIntermittentBuffer(0);
}

function button1Clicked() {
	playIntermittentBuffer(1);
}

function buttonClicked(buttonNumber) {
	playIntermittentBuffer(buttonNumber);
}

function playIntermittentBuffer(bufferIndex) {
	playBuffer(bufferIndex);
	var cueName = "cue" + bufferIndex;
	var randomPause = Math.random() * 1000. + 2000.;
	if (cues2Play[cueName] == "on") {
		// Note that passing functions as strings presents security risks
		// This will be replaced with the IntermittentSound functionality of Lysias
		window.setTimeout('playIntermittentBuffer(' + bufferIndex + ')', randomPause);
	}
}

function playBuffer(bufferIndex) {
	soundNode = audioCtx.createBufferSource();
	soundNode.buffer = audioBuffers[bufferIndex];
	
	var cuePitch = cues2Play.pitch;
	
	soundNode.playbackRate.value = cuePitch;
	soundNode.connect(gainNode);
	soundNode.start();
}

// for now, nudgeButton only plays a sound as a test
function nudgeButtonClicked() {
	playBuffer(1);
}

// when the listenButton is clicked, we start start polling for changes in the json file
function listenButtonClicked() {
	if(this.className == "off") {
		this.className = "on";
		this.innerHTML = "Stop Listening";
		// this line used to be directly linked to the listenButton's onclick property
		pollForChanges();
	} else {
		this.className = "off";
		this.innerHTML = "Listen";
	}
}

function pollForChanges(force) {
	getCues(force);
	window.setTimeout(pollForChanges, 1000., false);
}

function getCues(force) {
	var xhr;
	try{
		// Opera 8.0+, Firefox, Safari
		xhr = new XMLHttpRequest();
	} catch(e) {
		// Internet Explorer Browsers
		try{
			xhr = new ActiveXObject("Msxml2.XMLHTTP");
		} catch(e) {
			try{
				xhr = new ActiveXObject("Microsoft.XMLHTTP");
			} catch(e) {
				alert("Your browser apparently does not support AJAX.");
				return false;
			}
		}
	}
	xhr.onreadystatechange = function() {
		//alert("readyState: " + xhr.readyState + "; status: " + xhr.status);
		if (xhr.readyState == 4) {
			if (xhr.status == 200) {
				try {
					var newCues2Play = JSON.parse(xhr.responseText);
					cues2Play.pitch = newCues2Play.pitch;
					for (var cue in newCues2Play) {
						if (cue.slice(0, 3) == "cue") {
							if (cues2Play[cue] != newCues2Play[cue]) {
								cues2Play[cue] = newCues2Play[cue];
								if (cues2Play[cue] == "on") {
									var cueIndex = cue.slice(3);
									//alert(cueIndex);
									buttonClicked(cueIndex);
								}
							}
						}
						
					}
					
					/*
					
					// at some point I'll add back some of this functionality, specifically the panic button
					for (var cue in newCues2Play) {
							if (cues2Play[cue] != newCues2Play[cue]) {
								cues2Play[cue] = newCues2Play[cue];
								var cueIndex = cue.slice(3);
								if (cue != "panic") {
									if (cues2Play[cue] == "on") {
										buttonActivated(cueIndex);
									} else {
										buttonDeactivated(cueIndex);
									}
								} else {
									//alert("Start panicking!");
									stopEverything();
								}
							}
						}
					*/
				} catch(e) {
					// Of course we don't want to alert this; we want it to fail unobtrusively,
					// since all it means is that we got a bad json file... 
					var error = e;
				}
			}
		}
	}
	
	if (force) {
		// Adding a time stamp gives it a unique name which should force the browser to really read the json file
		// instead of using a cached version
		var currentTime = new Date();
		var timeStamp = currentTime.getTime();
		xhr.open('GET', 'cues.json?_=' + timeStamp, true);
		xhr.setRequestHeader('Cache-Control', 'no-cache');
	} else {
		xhr.open('GET', 'cues.json', true);
	}

	xhr.overrideMimeType("application/json");
	xhr.send(null);
}

</script>

</body>
</html>