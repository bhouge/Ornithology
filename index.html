<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ornithology</title>
</head>
<body>

<div id="buttons" align="center">

<button id="listen" class="off">Listen</button>
<button id="nudge" class="off">Nudge</button>

</div>

<p>
This is where fascinating things shall transpire.
</p>

<script src="scripts/BufferLoader.js"></script>

<script type="text/javascript">

// initializing our cues2Play variable
var cues2Play = { cue0: "off", cue1 : "off" };

// getting references to our buttons from the parent object
// note that I have renamed these from what we used in class to make the code clearer
var listenButton = document.getElementById("listen");
// nudgeButton doesn't do anything yet
var nudgeButton = document.getElementById("nudge");

// setting up what functions get called when the buttons are clicked
// for now, nudgeButton just plays a sound as a test.
listenButton.onclick = listenButtonClicked;
nudgeButton.onclick = button1Clicked;

// setting up our audio context and creating our master gain
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioCtx = new AudioContext();

var gainNode = audioCtx.createGain();
gainNode.connect(audioCtx.destination);
gainNode.gain.value = 1.0;

var soundNode;

// manually loading some sounds (courtesy of Neil Leonard)
var mySoundFileBuffer0, mySoundFileBuffer1;
var mySoundFileURL0 = 'sounds/Pan_1.112 2.mp4';
var mySoundFileURL1 = 'sounds/El caramelo de chocolate.97 1.mp4';

// for our first test, we copied an identical function twice, which is bad practice
// later we'll look at how to replace this with our BufferLoader script
// check out the PlayFile3 demo for a description of everything that's going on here
var request0 = new XMLHttpRequest();
request0.open('GET', mySoundFileURL0, true);
request0.responseType = 'arraybuffer';
request0.onload = function() {
	audioCtx.decodeAudioData(request0.response, function(buffer) {
		mySoundFileBuffer0 = buffer;
	}, function(error) {
        alert('decodeAudioData error!');
    });
}
request0.send();

var request1 = new XMLHttpRequest();
request1.open('GET', mySoundFileURL1, true);
request1.responseType = 'arraybuffer';
request1.onload = function() {
	audioCtx.decodeAudioData(request1.response, function(buffer) {
		mySoundFileBuffer1 = buffer;
	}, function(error) {
        alert('decodeAudioData error!');
    });
}
request1.send();

// See the comments in the PlayFile3 demo to review what's going on each of these steps
// And for some other options of what you can do when playing back a sound
function button0Clicked() {
	soundNode = audioCtx.createBufferSource();
	soundNode.buffer = mySoundFileBuffer0;
	//soundNode.playbackRate.value = 0.5;
	soundNode.connect(gainNode);
	soundNode.start();
}

function button1Clicked() {
	soundNode = audioCtx.createBufferSource();
	soundNode.buffer = mySoundFileBuffer1;
	//soundNode.playbackRate.value = 0.5;
	soundNode.connect(gainNode);
	soundNode.start();
}

// adding an intermediary function to extend what we did in class,
// so that instead of our nudgeButton calling pollForChanges directly, we let it toggle polling on/off

function listenButtonClicked() {
	if(this.className == "off") {
		this.className = "on";
		this.innerHTML = "Stop Listening";
		// this line used to be directly linked to the listenButton's onclick property
		pollForChanges();
	} else {
		this.className = "off";
		this.innerHTML = "Listen";
	}
}

function pollForChanges(force) {
	getCues(force);
	window.setTimeout(pollForChanges, 1000., false);
}

function getCues(force) {
	var xhr;
	try{
		// Opera 8.0+, Firefox, Safari
		xhr = new XMLHttpRequest();
	} catch(e) {
		// Internet Explorer Browsers
		try{
			xhr = new ActiveXObject("Msxml2.XMLHTTP");
		} catch(e) {
			try{
				xhr = new ActiveXObject("Microsoft.XMLHTTP");
			} catch(e) {
				alert("Your browser broke!");
				return false;
			}
		}
	}
	xhr.onreadystatechange = function() {
		//alert("readyState: " + xhr.readyState + "; status: " + xhr.status);
		if (xhr.readyState == 4) {
			if (xhr.status == 200) {
				try {
					var newCues2Play = JSON.parse(xhr.responseText);
					if (cues2Play.cue0 != newCues2Play.cue0) {
						cues2Play.cue0 = newCues2Play.cue0;
						if (cues2Play.cue0 == "on") {
							button0Clicked();
						}
						//alert(cues2Play.cue0);
					}
					if (cues2Play.cue1 != newCues2Play.cue1) {
						cues2Play.cue1 = newCues2Play.cue1;
						if (cues2Play.cue1 == "on") {
							button1Clicked();
						}
						//alert(cues2Play.cue1);
					}
					
					/*
					// took out the buffersAreLoaded check, as that happens back when you first click the Listen button
					for (var cue in newCues2Play) {
							if (cues2Play[cue] != newCues2Play[cue]) {
								cues2Play[cue] = newCues2Play[cue];
								var cueIndex = cue.slice(3);
								if (cue != "panic") {
									if (cues2Play[cue] == "on") {
										buttonActivated(cueIndex);
									} else {
										buttonDeactivated(cueIndex);
									}
								} else {
									//alert("Start panicking!");
									stopEverything();
								}
							}
						}
					*/
				} catch(e) {
					// Of course we don't want to alert this; we want it to fail unobtrusively,
					// since all it means is that we got a bad json file... 
					var error = e;
				}
			}
		}
	}
	
	if (force) {
		// Adding a time stamp gives it a unique name which should force the browser to actually read the json file
		// instead of using a cached version
		var currentTime = new Date();
		var timeStamp = currentTime.getTime();
		xhr.open('GET', 'cues.json?_=' + timeStamp, true);
		xhr.setRequestHeader('Cache-Control', 'no-cache');
	} else {
		xhr.open('GET', 'cues.json', true);
	}

	xhr.overrideMimeType("application/json");
	xhr.send(null);
}

</script>

</body>
</html>