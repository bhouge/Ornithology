<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chirp</title>
<link href="styles/birdss.css" rel="stylesheet" type="text/css">
</head>
<body>

<style type="text/css">
      canvas { border: 1px solid black; }
</style>

<h1>ORNITHOLOGICAL BLOGPOEM</h1>
<h2>by <a href="http://twitter.com/egabbert">Elisa Gabbert</a></h2>

<div id="scoreImage">

<p>
Touch or click in the box below to start the piece.
When you see an image of a bird, wait for the next music phrase to be displayed.
When you are finished singing the displayed phrase, touch or click on the box for the next phrase.
</p>


<canvas id="score"></canvas>

<div id="buttons">

<button id="previousPhrase">&lt;</button>
<button id="pitch" onclick="pitch()">F (176 Hz)</button>
<button id="startStop" class="off">start</button>
<button id="reset">reset</button>
<button id="nextPhrase"">&gt;</button>

</div>

</div>

<script src="scripts/BufferLoader.js"></script>
<script src="scripts/recorder.js"></script>
<script type="text/javascript">

//get access to the buttons as objects
var pitchButton = document.getElementById("pitch");
var resetButton = document.getElementById("reset");
var startStopButton = document.getElementById("startStop");
var previousPhraseButton = document.getElementById("previousPhrase");
var nextPhraseButton = document.getElementById("nextPhrase");
//var textField = document.getElementById("textField")
//var slider = document.getElementById("slider")
var scoreImage = document.getElementById("score");
//slider.value = 0;
//textField.value = "1.";
var canvas = document.getElementById('score');
canvas.width = window.innerWidth - 20;
// this value comes from the proportions of my longest phrase jpg.
canvas.height = canvas.width * 0.22;
var ctx = canvas.getContext('2d');

// assign what will happen when the buttons are clicked
//pitchButton.onclick = pitch;
resetButton.onclick = reset;
startStopButton.onclick = startStop;
nextPhraseButton.onclick = nextPhrase;
previousPhraseButton.onclick = previousPhrase;

scoreImage.addEventListener("click", pauseBetweenPhrases);

var pauseRanges = [[1., 5.],
                   [0.1, 0.5],
                   [1., 2.5]];

var poemLines = [["Ornithological Blogpoem by Elisa Gabbert (tap to begin)", 0., 0],
                 ["You will be woken by the chirping of the birds,", 0.25, 1],
                 ["which is the sound of their egos escaping from their bodies", 0., 1],
                 ["in loud and irregular streams.", 0., 2],
                 ["They are acupuncture birds;", 0.25, 1],
                 ["where the chirps fall on your eardrums corresponds to where you experience the pain.", 0., 2],
                 ["The birds have PhDs.", 0.25, 1],
                 ["They chirp out chapters from their dissertations.", 0., 2],
                 ["The birds do not agree that irony is dead.", 0., 2],
                 ["One of the birds has tried repeatedly to fall to its death", 0., 1],
                 ["but always starts flying at the last second.", 0., 2],
                 ["The birds are excessively vain about their wings.", 0.25, 1],
                 ["They have been known to assemble themselves into bridges and other structures.", 0., 1],
                 ["An obelisk of feathers.", 0., 2],
                 ["Do not feed the birds;", 0.25, 1],
                 ["they are following a strict high-protein diet.", 0., 2],
                 ["The birds are control freaks.", 0.25, 1],
                 ["Do not, under any circumstances, try to touch their beaks.", 0., 2],
                 ["One of the birds has assumed a leadership role.", 0.25, 1],
                 ["Another bird is plotting to assassinate it.", 0., 2],
                 ["Some items have gone missing from the kitchen.", 0.25, 1],
                 ["The birds are capable of eating almost anything but are far too discriminating.", 0., 2],
                 ["If you are lucky one morning the birds may chirp selections from your favorite opera.", 0., 1],
                 ["The birds are especially fond of Wagner.", 0., 1],
                 ["What would you like to hear?", 0., 2],
                 ["They have a very long waiting list and are nepotistic.", 0., 2],
                 ["Do not be afraid of angering the birds.", 0., 1],
                 ["What angers the birds is fear.", 0., 2]];


var twitterBird = new Image();
twitterBird.src = "scores/Twitter_logo_blue.jpg";
var scoreImages = [twitterBird];

var newScore;
for (var i = 1; i <= 27; i++) {
	if (i < 10) {
		newScore = "scores/0" + i + ".jpg";
	} else {
		newScore = "scores/" + i + ".jpg";
	}
	scoreImages[i] = new Image();
	scoreImages[i].src = newScore;
}


var currentPoemLine = 0;
displayScore();

var timerID;
var recordingTimeoutID;
var repeat = false;

function goToPhrase(phraseIndex) {
	currentPoemLine = phraseIndex;
	displayScore();
}

function displayScore() {
	if (currentPoemLine >= 1 && currentPoemLine <= 27) {
		var scaledImageX = canvas.width * (scoreImages[currentPoemLine].width / 1181.);
		var scaledImageY = scaledImageX * (scoreImages[currentPoemLine].height/scoreImages[currentPoemLine].width);
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.drawImage(scoreImages[currentPoemLine], 0, 0, scaledImageX, scaledImageY);
		//alert("canvas width: " + canvas.width + ", image width: " + scoreImages[currentPoemLine].width + ", scaled image width: " + Math.floor(scaledImageX));
	} else if (currentPoemLine == 0) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.font = "48px serif";
		ctx.fillText("Tap to begin.", 10, 50);
	} else {
		drawBird();
	}
}

function drawBird() {
	var scaledBirdWidth = (canvas.height / scoreImages[0].height) * scoreImages[0].width; 
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.drawImage(scoreImages[0], (canvas.width / 2.) - (scaledBirdWidth / 2.), 0, scaledBirdWidth, canvas.height);
}

function pauseBetweenPhrases() {
	/*
	if (recording) {
		stopGetAndPostAudio();
		recording = false;
		window.clearTimeout(recordingTimeoutID);
	}
	*/
	
	/*
	newScore = "scores/Twitter_logo_blue.jpg";
	scoreImage.src = newScore;
	*/
	drawBird();
	repeat = Math.random() < poemLines[currentPoemLine][1];
	// note that with the settings above, ends of sets are given a repeat value of 0
	// it would be possible to break this with the wrong data
	// e.g., if the end of the phrase would repeat, we'd have the wrong delay before the start of the next phrase
	// a solution would be instead to indicate whether it's the end of a set or not,
	// then set delay and repeats both based on that value.
	// play with it and decide if you'd rather have the clarity or the flexibility
	var min = pauseRanges[poemLines[currentPoemLine][2]][0] * 1000.;
	var max = pauseRanges[poemLines[currentPoemLine][2]][1] * 1000.;
	//alert("min: " + min + ", max: " + max);
	var randomPause = Math.random() * (max - min) + min;
	timerID = window.setTimeout(endOfRandomPause, randomPause);
}

function endOfRandomPause() {
	if (!repeat) {
		nextPhrase();
	} else {
		displayScore();
	}
}

function nextPhrase() {
	window.clearTimeout(timerID);
	if (currentPoemLine < poemLines.length - 1) {
		currentPoemLine++;
		/*
		if (currentPoemLine == 0) {
			currentPoemLine += 1;
		} else {
			var goToNextLineProbability = Math.random();
			if (goToNextLineProbability < 0.75) {
				currentPoemLine += 1;
			}
		}
		*/
	} else {
		currentPoemLine = 0;
	};
	goToPhrase(currentPoemLine);
	//startRecordingAudio();
	//recording = true;
	//recordingTimeoutID = window.setTimeout(recordingTimeout, 5000);
}

function previousPhrase() {
	window.clearTimeout(timerID);
	if (currentPoemLine > 0) {
		currentPoemLine--;
	}
	goToPhrase(currentPoemLine);
}

function reset() {
	window.clearTimeout(timerID);
	goToPhrase(0);
}

//a handy function that will work for whichever button is clicked, avoiding code duplication
function startStop() {
	// this refers to whichever button is clicked
	// right now does nothing, will eventually be used for turning recording on/off
	if (this.className == "off") {
		//pauseBetweenPhrases();
		this.className = "on";
		this.innerHTML = "stop";
	} else {
		this.className = "off";
		this.innerHTML = "start";
		//window.clearTimeout(timerID);
	}
}

var fileNode;
var gainNode;
function pitch() {
	//alert("yes, trying to play pitch");
	fileNode = audioCtx.createBufferSource();
	gainNode = audioCtx.createGain();
	gainNode.connect(audioCtx.destination);
	fileNode.buffer = audioBuffers[0];	
	fileNode.connect(gainNode);
	fileNode.playbackRate.value = 1.;
	fileNode.start(audioCtx.currentTime);
	//fileNode.start(slightDelay, 0.1, 1.);
	//gainNode.gain.setValueCurveAtTime(grainWindow, slightDelay, 1.);
}

/*
function recordingTimeout() {
	if (recording) {
		stopGetAndPostAudio();
		recording = false;
	}
}
*/



/*
//OK, here we create the object that represents a button for each line in the poem
//declare and initialize our cues2Play variable
var birdCues = {};
for (var line = 0; line < poemLines.length; line++) {
	birdCues["cue" + line] = "off";
}
birdCues.pitch = 1.;
birdCues.panic = "off";
//alert(birdCues.cue0);
//var cues2Play = { cue0: "off", cue1 : "off", cue2 : "off", pitch : 1. };

//when the page is first loaded, write a new cues.json script with the default values
updateCues();
*/

// ***** Let's see if we can move this to another file down the road...

// network and file loading stuff
var audioBuffers = [];
var buffersAreLoaded = false;

var AudioContext = (window.AudioContext || window.webkitAudioContext);
var audioCtx = new AudioContext();

var bufferLoader;
loadAudio();

function loadAudio() {
	bufferLoader = new BufferLoader(audioCtx, 
			'sounds/compressed/',
			['eeeeee.mp3'], 
			 finishedLoading);
	bufferLoader.load();
}

function finishedLoading(bufferList) {
	for (var i = 0; i < bufferList.length; ++i) {
		audioBuffers[i] = bufferList[i];
	}
	buffersAreLoaded = true;
}

/*
var source;
var recorder;
//var recording;
var recordings = [];
var recording = false;

function startUserMedia(stream) {
	source = audioCtx.createMediaStreamSource(stream);
	recorder = new Recorder(source);
}

function getBufferCallback(buffers) {
	//var newSource = audioCtx.createBufferSource();
	var newBuffer = audioCtx.createBuffer(2, buffers[0].length, audioCtx.sampleRate);
	newBuffer.getChannelData(0).set(buffers[0]);
	newBuffer.getChannelData(1).set(buffers[1]);
	recordings.push(newBuffer);
	recorder && recorder.exportWAV(function(blob) {
		postAudio(blob);
    });
}

function startUserMedia() {
	navigator.getUserMedia = (navigator.getUserMedia ||
	        navigator.webkitGetUserMedia ||
	        navigator.mozGetUserMedia ||
	        navigator.msGetUserMedia);

	if (navigator.getUserMedia) {
		navigator.getUserMedia(
		// constraints
		{ video: false, audio: true },
		// successCallback
		startUserMedia,
		// errorCallback
		function(err) {
			console.log("The following error occured: " + err);
		});
	} else {
		console.log("getUserMedia not supported");
	};
}

function postAudio(blob) {
	var xhr;
	
	try{
		// Opera 8.0+, Firefox, Safari
		xhr = new XMLHttpRequest();
	} catch(e) {
		// Internet Explorer Browsers
		try{
			xhr = new ActiveXObject("Msxml2.XMLHTTP");
		} catch(e) {
			try{
				xhr = new ActiveXObject("Microsoft.XMLHTTP");
			} catch(e) {
				// Not supported
				alert("There appears to be a problem with your browser.");
				return false;
			}
		}
	}

	
	xhr.onreadystatechange = function(){
		if (xhr.readyState == 4){
			//alert(xhr.responseText);
			var birdIndex = xhr.responseText.match("Birds(.*)\.wav")[1];
			birdCues["cue" + birdIndex] = "on";
			//alert(birdCues["cue" + birdIndex]);
			updateCues();
			// This is your notification that the file has actually successfully uploaded
			// So this is where you should update your cues.json file to tell audience members to download
		}
	}
	
	var fd = new FormData();
	//alert(blob);
	fd.append("birdAudio", blob, "Birds" + currentPoemLine + ".wav");
	
	xhr.open("POST","BirdRecorder.php",true);
	xhr.send(fd);
	
	recorder.clear();
}

function startRecordingAudio() {
	recorder.record();
}

function stopGetAndPostAudio() {
	recorder.stop();
	recorder.getBuffer(getBufferCallback);
}

function playRandomAudioBuffer() {
	var newSource = audioCtx.createBufferSource();
	var newIndex = Math.floor(Math.random() * recordings.length);
	newSource.buffer = recordings[newIndex];
	newSource.connect(audioCtx.destination);
	newSource.start();
}

// ***** The above should ideally all be in a different file...

*/

//var pitchMultiplier;

/*
function showSliderValue(newValue)
{
	var scaledValue = (newValue / 100.) * 31. + 1.;
	scaledValue = Math.round(scaledValue * 100.)/100.;
	textField.value = scaledValue;
	pitchMultiplier = scaledValue;
}
*/

/*
function updateValue() {
	birdCues.pitch = pitchMultiplier;
	updateCues();
}
*/

/*
function textFieldChangeValue(newValue) {
	slider.value = (newValue - 1.) * (100./31.);
	pitchMultiplier = newValue;
	updateValue();
}
*/


function updateCues(){
	var xhr;
	
	// try a bunch of different versions of the object to support different browsers
	try{
		// Opera 8.0+, Firefox, Safari
		xhr = new XMLHttpRequest();
	} catch(e) {
		// Internet Explorer Browsers
		try{
			xhr = new ActiveXObject("Msxml2.XMLHTTP");
		} catch(e) {
			try{
				xhr = new ActiveXObject("Microsoft.XMLHTTP");
			} catch(e) {
				// Something went wrong
				alert("There appears to be a problem with your browser.");
				return false;
			}
		}
	}
	
	// turn the object into a JSON string
	//var json = JSON.stringify(birdCues);
	var json = JSON.stringify(birdCues);
	// compress it from a "binary string" to 64bit ASCII
	// note how the php file does the inverse
	var encoded = btoa(json);
	
	// note that here we're using "POST" instead of "GET", which is what the index.html file uses
	xhr.open("POST", "Birds.php", true);
	// set the content type
	xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded');
	// prepend "var=" for the php script; see how it parses data it receives based on this prefix
	xhr.send('var=' + encoded);
}



</script>

</body>
</html>